# 新增策略开发指南

本文档详细介绍如何在因子挖掘系统中新增自定义策略。策略系统采用 v2 统一接口，通过继承 [`Strategy`](src/strategies/base/strategy.py:24) 基类并实现两个核心方法来实现策略功能。

## 目录

- [概述](#概述)
- [目录结构](#目录结构)
- [核心模块](#核心模块)
- [开发步骤](#开发步骤)
- [完整示例](#完整示例)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

## 概述

策略系统设计遵循以下原则：

1. **统一接口**：所有策略必须实现 `generate_signals()` 和 `size_positions()` 两个核心方法
2. **自动注册**：策略通过 `__init_subclass__` 自动注册到全局注册表
3. **配置驱动**：策略参数通过 `StrategyConfig` 配置，支持运行时调整
4. **类型安全**：使用 dataclass 和枚举确保类型安全

## 目录结构

策略文件应放置在以下位置：

```
src/strategies/
├── __init__.py              # 自动发现并加载所有策略
├── base/
│   └── strategy.py          # Strategy 基类和注册表
├── example/                 # 示例策略（参考实现）
│   ├── __init__.py
│   ├── simple_momentum.py   # 简单动量策略
│   └── simple_ma.py         # 简单均线策略
└── your_strategy.py         # 您的自定义策略
```

**推荐做法**：对于复杂的策略，在 `src/strategies/` 下创建独立目录：

```
src/strategies/
└── your_strategy/
    ├── __init__.py
    └── your_strategy.py     # 策略主文件
```

## 核心模块

### 1. 策略基类 ([`Strategy`](src/strategies/base/strategy.py:24))

所有策略必须继承 `Strategy` 抽象类：

```python
from src.strategies.base.strategy import Strategy, StrategyConfig
from src.core.types import Signal, OrderIntent, MarketData, PortfolioState, RiskState
from src.core.context import RunContext
```

#### 必须实现的方法

| 方法 | 作用 | 返回类型 |
|------|------|----------|
| [`generate_signals()`](src/strategies/base/strategy.py:62) | 根据市场数据生成交易信号 | `List[Signal]` |
| [`size_positions()`](src/strategies/base/strategy.py:80) | 根据信号计算目标仓位 | `List[OrderIntent]` |

#### 可选方法

| 方法 | 作用 | 默认行为 |
|------|------|----------|
| [`risk_checks()`](src/strategies/base/strategy.py:101) | 风险检查 | 基础黑名单和持仓限制检查 |
| [`on_fill()`](src/strategies/base/strategy.py:152) | 成交事件处理 | 空字典 |
| [`set_params()`](src/strategies/base/strategy.py:165) | 设置策略参数 | 更新配置参数 |

### 2. 策略配置 ([`StrategyConfig`](src/strategies/base/strategy.py:17))

```python
@dataclass
class StrategyConfig:
    strategy_id: str      # 策略唯一标识符
    timeframe: str        # 时间框架，如 "1d", "1h"
    params: Dict          # 策略参数字典
```

### 3. 核心数据类型 ([`src/core/types.py`](src/core/types.py))

#### Signal（信号）

```python
@dataclass
class Signal:
    ts_utc: datetime              # 信号生成时间
    symbol: str                   # 交易标的
    strategy_id: str              # 策略ID
    action: ActionType            # LONG/SHORT/FLAT
    strength: float               # 信号强度 (0-1)
    stop_price: Optional[float]   # 止损价
    take_profit: Optional[float]  # 止盈价
    ttl_bars: Optional[int]       # 信号有效期（bar数）
    metadata: Dict[str, Any]      # 元数据
```

#### OrderIntent（订单意图）

```python
@dataclass
class OrderIntent:
    ts_utc: datetime              # 订单生成时间
    symbol: str                   # 交易标的
    side: OrderSide               # BUY/SELL
    qty: float                    # 数量
    order_type: OrderType         # MKT/LMT/STP
    limit_price: Optional[float]  # 限价
    stop_price: Optional[float]   # 止损价
    strategy_id: str = ""         # 策略ID
    metadata: Dict[str, Any]      # 元数据
```

#### MarketData（市场数据）

```python
@dataclass
class MarketData:
    bars: pd.DataFrame              # 当日/当前周期数据
    bars_all: Optional[pd.DataFrame] # 完整历史数据
    features: Optional[pd.DataFrame] # 因子特征数据
    actions: Optional[pd.DataFrame]  # 公司行动数据
```

#### PortfolioState（组合状态）

```python
@dataclass
class PortfolioState:
    cash: float                    # 现金
    positions: Dict[str, float]    # 持仓 {symbol: qty}
    avg_price: Dict[str, float]    # 平均成本价
    equity: float                  # 总资产净值
    daily_loss: float              # 当日亏损
    metadata: Dict[str, Any]       # 元数据
```

#### RiskState（风险状态）

```python
@dataclass
class RiskState:
    daily_loss_limit: Optional[float]  # 日亏损限制
    max_position_size: Optional[float] # 单标最大仓位
    max_positions: Optional[int]       # 最大持仓数
    blacklist: List[str]               # 黑名单
    max_drawdown_limit: Optional[float] # 最大回撤限制
    metadata: Dict[str, Any]           # 元数据
```

## 开发步骤

### 步骤 1：创建策略文件

在 `src/strategies/` 下创建新策略文件，例如 `my_strategy.py`：

```python
"""
我的自定义策略
策略说明...
"""

from typing import List, Dict, Optional, Any
from src.strategies.base.strategy import Strategy, StrategyConfig
from src.core.types import (
    Signal, OrderIntent, MarketData, 
    PortfolioState, RiskState, ActionType, OrderSide, OrderType
)
from src.core.context import RunContext
from src.utils.logger import get_logger
```

### 步骤 2：定义策略类

```python
class MyStrategy(Strategy):
    """我的自定义策略 - 简短描述"""
    
    def __init__(self, config: Optional[StrategyConfig] = None):
        if config is None:
            config = StrategyConfig(
                strategy_id="my_strategy",       # 唯一ID，小写+下划线
                timeframe="1d",                  # 时间框架
                params={
                    # 在此定义策略参数
                    "symbols": ["SPY", "QQQ"],
                    "lookback_days": 20,
                    "threshold": 0.02,
                }
            )
        super().__init__(config)
        self.logger = get_logger("my_strategy")
        # 初始化额外的实例变量
```

### 步骤 3：实现 generate_signals() 方法

```python
    def generate_signals(
        self, 
        md: MarketData, 
        ctx: RunContext
    ) -> List[Signal]:
        """
        生成交易信号
        
        Args:
            md: 市场数据
            ctx: 运行上下文
            
        Returns:
            信号列表
        """
        self.logger.debug(f"生成信号: {ctx.now_utc}")
        signals = []
        
        try:
            # 获取参数
            symbols = self.config.params.get("symbols", [])
            lookback = int(self.config.params.get("lookback_days", 20))
            threshold = float(self.config.params.get("threshold", 0.02))
            
            if md.bars_all is None or md.bars_all.empty:
                return []
            
            for symbol in symbols:
                # 获取标的的历史数据
                bars = md.bars_all[md.bars_all['symbol'] == symbol]
                if len(bars) < lookback + 1:
                    continue
                
                # 计算信号逻辑
                current_price = float(bars.iloc[-1]['close'])
                past_price = float(bars.iloc[-lookback]['close'])
                returns = (current_price / past_price) - 1
                
                # 生成信号
                if returns > threshold:
                    signals.append(Signal(
                        ts_utc=ctx.now_utc,
                        symbol=symbol,
                        strategy_id=self.strategy_id,
                        action=ActionType.LONG,
                        strength=min(abs(returns), 1.0),
                        metadata={
                            "price": current_price,
                            "returns": returns,
                            "reason": "momentum_breakout"
                        }
                    ))
                    
        except Exception as e:
            self.logger.error(f"生成信号失败: {e}")
        
        return signals
```

### 步骤 4：实现 size_positions() 方法

```python
    def size_positions(
        self,
        signals: List[Signal],
        portfolio: PortfolioState,
        risk: RiskState,
        ctx: RunContext
    ) -> List[OrderIntent]:
        """
        计算目标仓位
        
        Args:
            signals: 信号列表
            portfolio: 组合状态
            risk: 风险状态
            ctx: 运行上下文
            
        Returns:
            订单意图列表
        """
        orders = []
        
        if not signals:
            # 无信号时平仓
            for symbol, qty in portfolio.positions.items():
                if abs(qty) > 1e-8:
                    orders.append(OrderIntent(
                        ts_utc=ctx.now_utc,
                        symbol=symbol,
                        side=OrderSide.SELL,
                        qty=float(abs(qty)),
                        order_type=OrderType.MKT,
                        strategy_id=self.strategy_id,
                        metadata={"reason": "no_signal"}
                    ))
            return orders
        
        # 等权分配
        weight = 1.0 / len(signals)
        target_symbols = {s.symbol for s in signals}
        
        # 卖出不在目标列表中的持仓
        for symbol, qty in portfolio.positions.items():
            if abs(qty) > 1e-8 and symbol not in target_symbols:
                orders.append(OrderIntent(
                    ts_utc=ctx.now_utc,
                    symbol=symbol,
                    side=OrderSide.SELL,
                    qty=float(abs(qty)),
                    order_type=OrderType.MKT,
                    strategy_id=self.strategy_id,
                    metadata={"reason": "rebalance"}
                ))
        
        # 买入目标标的
        for signal in signals:
            price = float(signal.metadata.get("price", 0))
            if price <= 0:
                continue
            
            target_value = portfolio.equity * weight
            current_qty = portfolio.positions.get(signal.symbol, 0)
            target_qty = target_value / price
            delta = target_qty - current_qty
            
            if abs(delta) > 0.001:
                orders.append(OrderIntent(
                    ts_utc=ctx.now_utc,
                    symbol=signal.symbol,
                    side=OrderSide.BUY,
                    qty=float(abs(delta)),
                    order_type=OrderType.MKT,
                    strategy_id=self.strategy_id,
                    metadata={
                        "reason": "signal",
                        "signal_strength": signal.strength
                    }
                ))
        
        return orders
```

### 步骤 5：验证自动注册

策略定义后会自动注册。验证方式：

```python
from src.strategies import strategy_registry

# 列出所有已注册的策略
print(strategy_registry.list_strategies())

# 获取特定策略
strategy = strategy_registry.get_strategy("my_strategy")
```

### 步骤 6：在回测中使用

```python
import asyncio
from datetime import date
from src.core.context import RunContext, Environment
from src.core.calendar import TradingCalendar
from src.evaluation.backtesting.engine import BacktestEngine
from src.strategies import strategy_registry

async def run_backtest():
    # 方法1：从注册表获取
    strategy = strategy_registry.get_strategy("my_strategy")
    
    # 或直接实例化
    # from src.strategies.my_strategy import MyStrategy
    # strategy = MyStrategy()
    
    engine = BacktestEngine(initial_capital=100000)
    
    ctx = RunContext(
        env=Environment.BACKTEST,
        run_id="my_backtest",
        trading_calendar=TradingCalendar(),
    )
    
    await engine.run(
        strategies=[strategy],
        universe=["SPY", "QQQ"],
        start=date(2024, 1, 1),
        end=date(2024, 12, 31),
        ctx=ctx,
    )

asyncio.run(run_backtest())
```

## 完整示例

以下是完整的策略模板，可直接复制使用：

```python
"""
策略名称
简要描述策略逻辑
"""

from typing import List, Dict, Optional, Any
from src.strategies.base.strategy import Strategy, StrategyConfig
from src.core.types import (
    Signal, OrderIntent, MarketData, 
    PortfolioState, RiskState, ActionType, OrderSide, OrderType
)
from src.core.context import RunContext
from src.utils.logger import get_logger


class MyStrategy(Strategy):
    """我的自定义策略 - 详细描述"""
    
    def __init__(self, config: Optional[StrategyConfig] = None):
        if config is None:
            config = StrategyConfig(
                strategy_id="my_strategy",
                timeframe="1d",
                params={
                    # 参数1
                    "symbols": ["SPY", "QQQ"],
                    # 参数2
                    "lookback_days": 20,
                    # 参数3
                    "threshold": 0.02,
                }
            )
        super().__init__(config)
        self.logger = get_logger("my_strategy")
        # 初始化额外变量
        # self._last_signal_time = None
    
    def generate_signals(
        self, 
        md: MarketData, 
        ctx: RunContext
    ) -> List[Signal]:
        """生成交易信号"""
        self.logger.debug(f"生成信号: {ctx.now_utc}")
        signals = []
        
        try:
            symbols = self.config.params.get("symbols", [])
            lookback = int(self.config.params.get("lookback_days", 20))
            
            if md.bars_all is None or md.bars_all.empty:
                return []
            
            for symbol in symbols:
                bars = md.bars_all[md.bars_all['symbol'] == symbol]
                if len(bars) < lookback + 1:
                    continue
                
                # 策略核心逻辑
                current_price = float(bars.iloc[-1]['close'])
                past_price = float(bars.iloc[-lookback]['close'])
                returns = (current_price / past_price) - 1
                
                threshold = float(self.config.params.get("threshold", 0.02))
                if returns > threshold:
                    signals.append(Signal(
                        ts_utc=ctx.now_utc,
                        symbol=symbol,
                        strategy_id=self.strategy_id,
                        action=ActionType.LONG,
                        strength=min(abs(returns), 1.0),
                        metadata={
                            "price": current_price,
                            "returns": returns,
                        }
                    ))
                    
        except Exception as e:
            self.logger.error(f"生成信号失败: {e}")
        
        return signals
    
    def size_positions(
        self,
        signals: List[Signal],
        portfolio: PortfolioState,
        risk: RiskState,
        ctx: RunContext
    ) -> List[OrderIntent]:
        """计算目标仓位"""
        orders = []
        
        if not signals:
            for symbol, qty in portfolio.positions.items():
                if abs(qty) > 1e-8:
                    orders.append(OrderIntent(
                        ts_utc=ctx.now_utc,
                        symbol=symbol,
                        side=OrderSide.SELL,
                        qty=float(abs(qty)),
                        order_type=OrderType.MKT,
                        strategy_id=self.strategy_id,
                        metadata={"reason": "no_signal"}
                    ))
            return orders
        
        weight = 1.0 / len(signals)
        target_symbols = {s.symbol for s in signals}
        
        for symbol, qty in portfolio.positions.items():
            if abs(qty) > 1e-8 and symbol not in target_symbols:
                orders.append(OrderIntent(
                    ts_utc=ctx.now_utc,
                    symbol=symbol,
                    side=OrderSide.SELL,
                    qty=float(abs(qty)),
                    order_type=OrderType.MKT,
                    strategy_id=self.strategy_id,
                    metadata={"reason": "rebalance"}
                ))
        
        for signal in signals:
            price = float(signal.metadata.get("price", 0))
            if price <= 0:
                continue
            
            target_qty = (portfolio.equity * weight) / price
            current_qty = portfolio.positions.get(signal.symbol, 0)
            delta = target_qty - current_qty
            
            if abs(delta) > 0.001:
                orders.append(OrderIntent(
                    ts_utc=ctx.now_utc,
                    symbol=signal.symbol,
                    side=OrderSide.BUY,
                    qty=float(abs(delta)),
                    order_type=OrderType.MKT,
                    strategy_id=self.strategy_id,
                    metadata={"reason": "signal"}
                ))
        
        return orders
```

## 最佳实践

### 1. 参数命名规范

- 使用小写字母和下划线：`lookback_days`, `threshold`
- 提供合理的默认值
- 在文档字符串中说明每个参数的含义

### 2. 日志记录

```python
# 使用 Loguru  logger
self.logger.debug(f"详细调试信息: {detail}")
self.logger.info(f"生成 {len(signals)} 个信号")
self.logger.warning(f"数据不足，跳过 {symbol}")
self.logger.error(f"计算失败: {e}")
```

### 3. 错误处理

```python
def generate_signals(self, md: MarketData, ctx: RunContext) -> List[Signal]:
    try:
        # 核心逻辑
        pass
    except KeyError as e:
        self.logger.error(f"数据缺失: {e}")
        return []
    except Exception as e:
        self.logger.error(f"生成信号失败: {e}")
        return []  # 静默失败，避免中断回测
```

### 4. 数据访问安全

```python
# 检查数据是否为空
if md.bars_all is None or md.bars_all.empty:
    return []

# 检查数据长度
if len(bars) < min_required:
    continue

# 安全获取数值
price = float(bars.iloc[-1]['close'])
```

### 5. 使用 metadata 传递额外信息

```python
Signal(
    ts_utc=ctx.now_utc,
    symbol=symbol,
    strategy_id=self.strategy_id,
    action=ActionType.LONG,
    strength=strength,
    metadata={
        "price": price,
        "returns": returns,
        "factor_value": factor_value,
        # 任何需要传递的信息
    }
)
```

### 6. 避免前视偏差

```python
# 错误：使用未来数据
current_price = float(bars.iloc[0]['close'])  # 最早的价格

# 正确：使用当前/最近的价格
current_price = float(bars.iloc[-1]['close'])  # 最近的价格
```

## 常见问题

### Q1: 策略没有自动注册？

1. 检查文件是否在 `src/strategies/` 目录下
2. 确保策略类继承了 `Strategy`
3. 确保类不是抽象类（没有 `@abstractmethod` 方法）
4. 检查 `__init_subclass__` 没有被跳过

### Q2: 如何调试策略？

```python
from src.strategies import strategy_registry

# 获取策略实例
strategy = strategy_registry.get_strategy("my_strategy")

# 检查配置
print(strategy.config.params)

# 手动调用方法
signals = strategy.generate_signals(md, ctx)
```

### Q3: 如何在运行时修改参数？

```python
# 方法1：通过 set_params
strategy.set_params({"threshold": 0.03})

# 方法2：直接修改 config.params
strategy.config.params["lookback_days"] = 30

# 方法3：创建新配置
from src.strategies.base.strategy import StrategyConfig
new_config = StrategyConfig(
    strategy_id="my_strategy",
    timeframe="1d",
    params={"threshold": 0.03}
)
strategy = MyStrategy(config=new_config)
```

### Q4: 如何实现更复杂的仓位管理？

重写 `size_positions()` 方法，根据以下因素计算仓位：

- 组合 equity
- 信号 strength
- 波动率调整
- 风险敞口限制
- 相关性分散

### Q5: 如何添加风控逻辑？

两种方式：

1. **在 size_positions 中处理**（推荐）
```python
def size_positions(self, signals, portfolio, risk, ctx):
    # 检查黑名单
    if signal.symbol in risk.blacklist:
        continue
    
    # 检查最大持仓数
    if risk.max_positions is not None:
        if len(portfolio.positions) >= risk.max_positions:
            break
```

2. **重写 risk_checks 方法**
```python
def risk_checks(self, order_intents, portfolio, risk, ctx):
    approved = []
    blocks = []
    # 自定义逻辑
    return approved, blocks
```

## 相关文档

- [策略系统使用指南](src/strategies/README.md)
- [API 路由文档](src/api/routers/AGENTS.md)
- [回测引擎文档](src/evaluation/backtesting/engine.py)
- [核心类型定义](src/core/types.py)
